<?xml version="1.0"?>
<!--
Generated by VSdocman, see http://www.helixoft.com
-->
<doc>
  <assembly>
    <name>SPL_Small_Programming_Language</name>
  </assembly>
  <members>
    <member name="T:SDK.FrmPL_REPL">
    </member>
    <member name="F:SDK.FrmPL_REPL.PSER">
    </member>
    <member name="M:SDK.FrmPL_REPL.ToolStripButtonCompile_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.loadTree(SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram@)">
      <param name="Prog">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.OpenToolStripButton_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.SaveToolStripButton_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.NewToolStripButton_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.HelpToolStripButton_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="F:SDK.FrmPL_REPL.VM">
    </member>
    <member name="M:SDK.FrmPL_REPL.ButtonOpenVM_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmPL_REPL.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.FrmPL_REPL.components">
    </member>
    <member name="M:SDK.FrmPL_REPL.InitializeComponent">
    </member>
    <member name="T:SDK.FrmSal_Repl">
    </member>
    <member name="M:SDK.FrmSal_Repl.ToolStripButtonCompileCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FrmSal_Repl.DisplayOutput(System.String@)">
      <param name="OutputStr">
</param>
    </member>
    <member name="M:SDK.FrmSal_Repl.DisplayError(System.String@)">
      <param name="ErrorStr">
</param>
    </member>
    <member name="M:SDK.FrmSal_Repl.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.FrmSal_Repl.components">
    </member>
    <member name="M:SDK.FrmSal_Repl.InitializeComponent">
    </member>
    <member name="N:SDK.Repl">
    </member>
    <member name="T:SDK.Repl.PL_ReplErrorSystem">
    </member>
    <member name="M:SDK.Repl.PL_ReplErrorSystem.DisplayError(System.String@,SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal@)">
      <summary>
Creates an Error Message to be displayed</summary>
      <param name="ErrorStr">
</param>
      <param name="Errtok">
</param>
    </member>
    <member name="T:SDK.Repl.SAL_ReplErrorSystem">
    </member>
    <member name="M:SDK.Repl.SAL_ReplErrorSystem.DisplayError(System.String@,System.String@)">
      <summary>
Creates an Error Message to be displayed</summary>
      <param name="ErrorStr">
</param>
      <param name="Errtok">
</param>
    </member>
    <member name="T:SDK.EMU_MachineUI">
    </member>
    <member name="M:SDK.EMU_MachineUI.GoUrl(System.String@)">
      <param name="Url">
</param>
    </member>
    <member name="M:SDK.EMU_MachineUI.GetUrl(System.String@)">
      <param name="Text">
</param>
    </member>
    <member name="M:SDK.EMU_MachineUI.ButtonRunCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.EMU_MachineUI.ButtonNewScrn_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.EMU_MachineUI.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.EMU_MachineUI.components">
    </member>
    <member name="M:SDK.EMU_MachineUI.InitializeComponent">
    </member>
    <member name="T:SDK.FormDisplayConsole">
    </member>
    <member name="M:SDK.FormDisplayConsole.Print(System.String@)">
      <param name="Userinput">
</param>
    </member>
    <member name="M:SDK.FormDisplayConsole.CLS">
    </member>
    <member name="M:SDK.FormDisplayConsole.Input(System.String@)">
      <param name="Message">
</param>
    </member>
    <member name="M:SDK.FormDisplayConsole.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.FormDisplayConsole.components">
    </member>
    <member name="M:SDK.FormDisplayConsole.InitializeComponent">
    </member>
    <member name="T:SDK.VM_MachineUI">
    </member>
    <member name="M:SDK.VM_MachineUI.ExecuteCode(System.String@)">
      <param name="Code">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonRunCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonNewScrn_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonClrScrn_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.DISPLAY_TEXT(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonRef_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.VM_MachineUI.components">
    </member>
    <member name="M:SDK.VM_MachineUI.InitializeComponent">
    </member>
    <member name="N:SDK.SAL">
    </member>
    <member name="T:SDK.SAL.Ext">
    </member>
    <member name="M:SDK.SAL.Ext.SplitAtNewLine(System.String)">
      <param name="input">
</param>
    </member>
    <member name="M:SDK.SAL.Ext.ExtractLastChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="M:SDK.SAL.Ext.ExtractFirstChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="T:SDK.SAL.SalCode_Helpers">
    </member>
    <member name="M:SDK.SAL.SalCode_Helpers._Binary_op(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.SAL.SalCode_Helpers._CheckCondition(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.SAL.SalCode_Helpers._print(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:SDK.SAL.SalCode_Helpers._if_then(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"] End</param>
    </member>
    <member name="M:SDK.SAL.SalCode_Helpers._if_then_else(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] ELSE ["If-False"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"]</param>
      <param name="_Else">
ELSE ["If-False"]</param>
    </member>
    <member name="T:SDK.SAL.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:SDK.SAL.StackMemoryFrame.Var">
    </member>
    <member name="F:SDK.SAL.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:SDK.SAL.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:SDK.SAL.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:SDK.SAL.StackMemoryFrame.Variables">
    </member>
    <member name="M:SDK.SAL.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:SDK.SAL.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:SDK.SAL.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:SDK.SAL.StackMemoryFrame.SetVar(System.String@,System.Int32@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="T:SDK.SAL.X86API">
    </member>
    <member name="M:SDK.SAL.X86API.RunMachineCode(System.String@)">
      <param name="Code">
</param>
    </member>
    <member name="F:SDK.SAL.X86API.Tree">
    </member>
    <member name="T:SDK.SAL.ZX81_CPU">
      <summary>
SpydazWeb X86 Assembly language Virtual X86 Processor</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.GPU">
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.RunningState">
      <summary>
Used to monitor the Program status ; If the program is being executed then the cpu must be running the Property value can only be changed within the program</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.mRunningState">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.CPU_CACHE">
      <summary>
This is the cpu stack memory space; Items being interrogated will be placed in this memeory frame calling functions will access this frame ; the cpu stack can be considered to be a bus; Functions are devices / or gate logic which is connected to the bus via the cpu;</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.GetInstructionAddress">
      <summary>
Returns the Current position of the instruction Pointer in the Program being executed The instruction Pionet can be manipulated Jumping backwards and forwards in the program code.</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.Get_Instruction_Pointer_Position">
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.Get_Current_Stack_Data">
      <summary>
Returns the current data in the stack</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.View_C_P_U">
      <summary>
Returns the Current Cache (the stack)</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.Get_Current_Stack_Item">
      <summary>
Returns the current object on top of the stack</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.CPU_ERR">
      <summary>
Used to pass the intensive error messaging required;</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.ProgramData">
      <summary>
Used to hold the Program being sent to the CPU A list of objects has been chosen to allow for a Richer CPU enabling for objects to be passed instead of strings; due to this being a compiler as well as a morenized CPU converting strings to string or integers or booleans etc makes it much harder to create quick easy code; the sender is expeected to understand the logic of the items in the program the decoder only decodes bassed on what is expected;</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.InstructionAdrress">
      <summary>
the InstructionAdrress is the current position in the program; it could be considered to be the line numbe</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.PROCESS_NAME">
      <summary>
Name of current program or process running in CPU thread</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.CurrentCache">
      <summary>
Used for local memory frame</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.R_A_M">
      <summary>
Used to Store memory frames (The Heap)</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.View_R_A_M">
      <summary>
Returns the Ram as a Stack of Stack Memeory frames;</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.WaitTime">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.#ctor(System.String@)">
      <summary>
Each Program can be considered to be a task or thread; A name should be assigned to the Process; Processes themselves can be stacked in a higher level processor, allowing for paralel processing of code This process allows for the initialization of the CPU; THe Prgram will still need to be loaded</summary>
      <param name="ThreadName">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.#ctor(System.String@,System.Collections.Generic.List{System.String}@)">
      <summary>
Load Program and Executes Code on CPU</summary>
      <param name="ThreadName">
A name is required to Identify the Process</param>
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.String}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.Object}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.RUN">
      <summary>
Begins eexecution of the instructions held in program data</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.IsHalted">
      <summary>
Checks the status of the cpu</summary>
    </member>
    <member name="P:SDK.SAL.ZX81_CPU.IsWait">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.EXECUTE">
      <summary>
Executes the next instruction in the Program Each Instruction is fed individually to the decoder : The Execute cycle Checks the Current State to determine if to fetch the next instruction to be decoded;(or EXECUTED) - The decoder contains the Chip logic</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.Fetch">
      <summary>
Program Instructions can be boolean/String or integer so an object is assumed enabling for later classification of the instructions at the decoder level : The Fetch Cycle Fetches the next Instruction in the Program to be executed: It is fed to the decoder to be decoded and executed</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.DECODE(System.Object@)">
      <summary>
Contains MainInstruction Set: Decode Cycle Decodes program instructions from the program the Insruction pointer points to the current Instruction being feed into the decoder: Important Note : the stack will always point to the data at top of the CPU CACHE (Which is Working Memory); THe memory frames being used are Extensions of this memeory and can be seen as registers, itself being a memory stack (stack of memory frames)</summary>
      <param name="ProgramInstruction">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.ToInt(System.Boolean@)">
      <param name="Bool">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.NOT_ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.CheckJumpAddress(System.Int32@)">
      <summary>
Checks if there is a jump address available</summary>
      <param name="address">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.CheckThereIsAReturnAddress">
      <summary>
Function used by the internal functions to check if there is a return address</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.GetCurrentFrame">
      <summary>
RAM is a STACK MEMORY - Here we can take a look at the stack item</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.GetStackData">
      <summary>
Outputs stack data for verbose output</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.ToJson(System.Object@)">
      <param name="OBJ">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.Peek">
      <summary>
REQUIRED TO SEE IN-SIDE CURRENT POINTER LOCATION ----------Public For Testing Purposes-----------</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.BINARYOP(System.String@,System.Int32,System.Int32)">
      <param name="INSTRUCTION">
</param>
      <param name="LEFT">
</param>
      <param name="RIGHT">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.CheckStackHasAtLeastOneItem(System.Collections.Stack@)">
      <param name="Current">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.CheckStackHasAtLeastOneItem">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.CheckRamHasAtLeastOneItem">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.JumpIf_TRUE(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.JUMP(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.JumpIf_False(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.Push(System.Object@)">
      <summary>
Puts a value on the cpu stack to be available to funcitons</summary>
      <param name="Value">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.Pop">
      <summary>
Pops a value of the cpu_Stack (current workspace)</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.ToPositive(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.ToNegative(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="T:SDK.SAL.ZX81_CPU.State">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.State.RUN">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.State.HALT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.State.PAUSE">
    </member>
    <member name="T:SDK.SAL.ZX81_CPU.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:SDK.SAL.ZX81_CPU.StackMemoryFrame.Var">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.StackMemoryFrame.Variables">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.StackMemoryFrame.SetVar(System.String@,System.String@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.StackMemoryFrame.RemoveVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="T:SDK.SAL.ZX81_CPU.VM_ERR">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_ERR.ErrorStr">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_ERR.frm">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_ERR.CpuCurrentState">
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.VM_ERR.#ctor(System.String@,SDK.SAL.ZX81_CPU)">
      <param name="Err">
</param>
      <param name="CPUSTATE">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_CPU.VM_ERR.RaiseErr">
    </member>
    <member name="T:SDK.SAL.ZX81_CPU.VM_x86_Cmds">
      <summary>
COMMANDS FOR ASSEMBLY LANGUAGE FOR THIS CPU SPYDAZWEB_VM_X86</summary>
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._NULL">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._REMOVE">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._RESUME">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PUSH">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PULL">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PEEK">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._WAIT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PAUSE">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._HALT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._DUP">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JMP">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JIF_T">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JIF_F">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JIF_EQ">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JIF_GT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._JIF_LT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._LOAD">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._STORE">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._CALL">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._RET">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PRINT_M">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._PRINT_C">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._ADD">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._SUB">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._MUL">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._DIV">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._AND">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._OR">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._NOT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._IS_EQ">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._IS_GT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._IS_GTE">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._IS_LT">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._IS_LTE">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._TO_POS">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._TO_NEG">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._INCR">
    </member>
    <member name="F:SDK.SAL.ZX81_CPU.VM_x86_Cmds._DECR">
    </member>
    <member name="T:SDK.SAL.ZX81_GPU">
    </member>
    <member name="F:SDK.SAL.ZX81_GPU.iMonitorConsole">
    </member>
    <member name="M:SDK.SAL.ZX81_GPU.#ctor">
    </member>
    <member name="M:SDK.SAL.ZX81_GPU.ConsolePrint(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_GPU.Console_CLS">
    </member>
    <member name="T:SDK.SAL.ZX81_RAM">
    </member>
    <member name="T:SDK.SAL.ZX81_RAM.Variable">
    </member>
    <member name="F:SDK.SAL.ZX81_RAM.Variable.iName">
    </member>
    <member name="F:SDK.SAL.ZX81_RAM.Variable.iValue">
    </member>
    <member name="F:SDK.SAL.ZX81_RAM.Variable.iType">
    </member>
    <member name="F:SDK.SAL.ZX81_RAM.CurrentVars">
      <summary>
Currently only Variables can be stored</summary>
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.#ctor">
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.UpdateVar(System.String@,System.String@)">
      <param name="VarName">
</param>
      <param name="iVALUE">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.RemoveVar(SDK.SAL.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.AddVar(SDK.SAL.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.CheckVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="M:SDK.SAL.ZX81_RAM.GetVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="N:SDK.ExpressionEvaluators">
    </member>
    <member name="T:SDK.ExpressionEvaluators.Expression">
      <summary>
To be Used as a Node in a Syntax Tree</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.Expression.Expr">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Expression.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Expression.GetExpr">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Expression.NodeType">
      <summary>
Type = "Parameter" / "Variable Assignment"</summary>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Expression.#ctor(System.String@)">
      <param name="NodeType">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.ConstantExpression">
      <summary>
Used For values ie:Integers</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.ConstantExpression.iValue">
      <summary>
Used as a literal for the final data item Value Held ie: 5 or CAT</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.ConstantExpression.VarType">
      <summary>
ie: Integer / String</summary>
    </member>
    <member name="M:SDK.ExpressionEvaluators.ConstantExpression.GetValue">
    </member>
    <member name="M:SDK.ExpressionEvaluators.ConstantExpression.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.ConstantExpression.#ctor(System.String@,System.String@,System.String@)">
      <param name="NodeType">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.ConstantExpression.#ctor(System.String@)">
      <param name="NodeType">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.UnaryExpression">
    </member>
    <member name="F:SDK.ExpressionEvaluators.UnaryExpression.Identifier">
    </member>
    <member name="F:SDK.ExpressionEvaluators.UnaryExpression.ParentEnv">
    </member>
    <member name="M:SDK.ExpressionEvaluators.UnaryExpression.#ctor(System.String@,System.String@,System.String@,System.String@,SDK.SAL.ZX81_RAM@)">
      <param name="NodeType">
</param>
      <param name="iName">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
      <param name="Env">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.UnaryExpression.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.UnaryExpression.GetValue">
    </member>
    <member name="M:SDK.ExpressionEvaluators.UnaryExpression.GetName">
    </member>
    <member name="T:SDK.ExpressionEvaluators.BinaryExpression">
      <summary>
The Binary Expression is a function, the execution of the node structure is performed by the get data functions This class must be inherited and its Get Data function Implemented With its custom Used for Functions A+1 = iOperator = "+" Nodetype = "ADD" (LeftNode = ParameterExpression(Parameter/5/a/int)) (RightNode = ConstantExpression (number/1/int/))</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.BinaryExpression.iOperator">
      <summary>
Operator such as "+" or "DIM"</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.BinaryExpression.Left">
      <summary>
(LeftNode = ParameterExpression(Parameter/5/a/int))</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.BinaryExpression.Right">
      <summary>
(RightNode = ConstantExpression (number/1/int/))</summary>
    </member>
    <member name="M:SDK.ExpressionEvaluators.BinaryExpression.#ctor(System.String@,System.String@,System.String@,System.String@,SDK.SAL.ZX81_RAM@)">
      <param name="NodeType">
</param>
      <param name="iName">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
      <param name="Env">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.Body">
      <summary>
A body is a list of statements Which is a list of Binary Expressions. Essentially Each Binary Expression is a single Segment of Code</summary>
    </member>
    <member name="F:SDK.ExpressionEvaluators.Body.Statements">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Body.#ctor(System.String@,SDK.ExpressionEvaluators.Expression@)">
      <param name="Nodetype">
</param>
      <param name="Statment">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Body.#ctor(System.String@,System.Collections.Generic.List{SDK.ExpressionEvaluators.Expression}@)">
      <param name="Nodetype">
</param>
      <param name="Program">
</param>
    </member>
    <member name="N:SDK.ExpressionEvaluators.Operations">
    </member>
    <member name="T:SDK.ExpressionEvaluators.Operations.ConditionalOperation">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Operations.ConditionalOperation.Env">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.ConditionalOperation.#ctor(SDK.ExpressionEvaluators.ConstantExpression@,System.String,SDK.ExpressionEvaluators.ConstantExpression,SDK.SAL.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.ConditionalOperation.GetValue">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.ConditionalOperation.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.ConditionalOperation.EvaluateBoolean(SDK.ExpressionEvaluators.ConstantExpression@,System.String@,SDK.ExpressionEvaluators.ConstantExpression@)">
      <summary>
Evaluate node values ( imeadiatly invoked expression )</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.Operations.AddativeOperation">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Operations.AddativeOperation.Env">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.AddativeOperation.#ctor(SDK.ExpressionEvaluators.ConstantExpression@,System.String,SDK.ExpressionEvaluators.ConstantExpression,SDK.SAL.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.AddativeOperation.GetValue">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.AddativeOperation.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.AddativeOperation.EvaluateAddative(SDK.ExpressionEvaluators.ConstantExpression@,System.String@,SDK.ExpressionEvaluators.ConstantExpression@)">
      <summary>
Enables for evaluation of the node / Imediatly invoked expression</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation.env">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation.#ctor(SDK.ExpressionEvaluators.ConstantExpression@,System.String,SDK.ExpressionEvaluators.ConstantExpression,SDK.SAL.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation.GetValue">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.MultiplicativeOperation.EvaluateMultiplicative(SDK.ExpressionEvaluators.ConstantExpression@,System.String@,SDK.ExpressionEvaluators.ConstantExpression@)">
      <summary>
Allows for evaluation of the node : Imeadialty invoked expression</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:SDK.ExpressionEvaluators.Operations.PrintFunction">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Operations.PrintFunction.ToPrint">
    </member>
    <member name="F:SDK.ExpressionEvaluators.Operations.PrintFunction.ParentEnv">
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.UnaryExpression@,SDK.SAL.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.ConstantExpression@,SDK.SAL.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.BinaryExpression@)">
      <param name="ToPrint">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.Operations.ConditionalOperation@,SDK.SAL.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.Operations.MultiplicativeOperation@,SDK.SAL.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.#ctor(SDK.ExpressionEvaluators.Operations.AddativeOperation@,SDK.SAL.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:SDK.ExpressionEvaluators.Operations.PrintFunction.Evaluate(SDK.SAL.ZX81_RAM@)">
      <param name="ParentEnV">
</param>
    </member>
    <member name="N:SDK.SmallProgLang">
    </member>
    <member name="N:SDK.SmallProgLang.Ast_ExpressionFactory">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression._Left">
      <summary>
Must be var literal type</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression._Right">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression._Operator">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier@,System.String@,SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression@)">
      <param name="nLeft">
</param>
      <param name="nOperator">
</param>
      <param name="nRight">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression.ToArrayList">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_AssignmentExpression.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_BlockExpression">
      <summary>
Used for CodeBlocks</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_BlockExpression.Body">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_BlockExpression.#ctor(System.Collections.Generic.List{SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement}@)">
      <param name="iBody">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_BlockExpression.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_BlockExpression.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner">
      <summary>
Used To Remove Erronious Tokens Such as _WhiteSpace _EmptyStatment Unwanted tokens Are useful to be collected in the parser Stage to give the user a richer experience as well as help with debuggin.</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner._Program">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.RemovedNodes">
      <summary>
Removed Nodes are Preserved</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.iCleanedProgram">
    </member>
    <member name="P:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.CleanedProgram">
      <summary>
Cleaned !</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram@)">
      <summary>
Cleans unwanted tokens from Program The final Output program should be a clean ordered set of Expressions Each Expression Should have an Arraylist function, A final output of List/OfLists (Tree) can be returned Or the Cleaned Program</summary>
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner._CleanAST(SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram@)">
      <summary>
-RemoveWhiteSpace Tokens -RemoveEmptyStatments Tokens</summary>
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner._RemoveWhiteSpace(SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram@)">
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.RemoveEmptyStatments(SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram@)">
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AST_Cleaner.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement">
      <summary>
Syntax: Expression Statement Types</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement._Expression">
      <summary>
Literal Value</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal@)">
      <param name="nValue">
Literal Value to be stored</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ExpressionStatement.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier">
      <summary>
Syntax: Used to hold Varnames or Identifiers</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier._Name">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier.#ctor(System.String@)">
      <param name="nName">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal">
      <summary>
Syntax: Used to hold Literals and values</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal.iLiteral">
      <summary>
Holds value (in its type)</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE@)">
      <param name="ntype">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE@,System.Object@)">
      <param name="ntype">
</param>
      <param name="nValue">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Literal.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ParenthesizedExpresion">
      <summary>
Used for Operational Expression</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ParenthesizedExpresion.Body">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ParenthesizedExpresion.#ctor(System.Collections.Generic.List{SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression}@)">
      <param name="iBody">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_ParenthesizedExpresion.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_VariableExpressionStatement">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_VariableExpressionStatement._Expression">
      <summary>
Literal Value</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_VariableExpressionStatement.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.Ast_Identifier@)">
      <param name="nValue">
Literal Value to be stored</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_VariableExpressionStatement.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.Ast_VariableExpressionStatement.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression">
      <summary>
Used for Binary Operations</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression._Left">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression._Right">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression._Operator">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE@,SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression@,System.String@,SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression@)">
      <param name="nType">
</param>
      <param name="nLeft">
</param>
      <param name="nOperator">
</param>
      <param name="nRight">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstBinaryExpression.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression">
      <summary>
Expression Model Used To Group Expressions</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE@)">
      <param name="ntype">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE">
      <summary>
Ast NodeTypes Used to Describe AST Node</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._array">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._boolean">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._string">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._integer">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._variable">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._null">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._endStatement">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._blockCode">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._binaryExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._OperationalExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._MultiplicativeExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._AddativeExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._assignExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Dim">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._For">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._If">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._function">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._sub">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._class">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._else">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._then">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Do_while">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Do_until">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Program">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._comments">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._ExpressionStatement">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._WhiteSpace">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._UnknownStatement">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Code_Begin">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._Code_End">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._emptyStatement">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._OperationBegin">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._OperationEnd">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE._ConditionalExpression">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_NULL">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_REMOVE">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_RESUME">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PUSH">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PULL">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PEEK">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_WAIT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PAUSE">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_HALT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_DUP">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JMP">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JIF_T">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JIF_F">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JIF_EQ">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JIF_GT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_JIF_LT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_LOAD">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_STORE">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_CALL">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_RET">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PRINT_M">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_PRINT_C">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_ADD">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_SUB">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_MUL">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_DIV">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_AND">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_OR">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_NOT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_IS_EQ">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_IS_GT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_IS_GTE">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_IS_LT">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_IS_LTE">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_TO_POS">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_TO_NEG">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_INCR">
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE.SAL_DECR">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode">
      <summary>
Syntax: Root Ast node Type</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode._Type">
      <summary>
Type Of Node</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode._TypeStr">
      <summary>
String version of the Type due to not being printed</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode._Start">
      <summary>
Start Position</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode._End">
      <summary>
End Position</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode._Raw">
      <summary>
Raw data of token</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode.#ctor(SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE@)">
      <summary>
Instanciate</summary>
      <param name="ntype">
Type of Node</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstNode.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram">
      <summary>
Syntax : Based on AST Explorer output { "type": "Program", "start": 0, "end": 2, "body": [ { "type": "ExpressionStatement", "start": 0, "end": 2, "expression": { "type": "Literal", "start": 0, "end": 2, "value": 42, "raw": "42" } } ], }</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram.Body">
      <summary>
Expression List</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram.#ctor(System.Collections.Generic.List{SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression}@)">
      <summary>
Instanciate Expression</summary>
      <param name="nBody">
Expressions</param>
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram.ToArraylist">
    </member>
    <member name="M:SDK.SmallProgLang.Ast_ExpressionFactory.AstProgram.GetDebuggerDisplay">
    </member>
    <member name="N:SDK.SmallProgLang.Compiler">
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.EnvironmentalMemory">
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.EnvironmentalMemory.Variable">
      <summary>
Structure for variable</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.EnvironmentalMemory.Variable.Name">
      <summary>
Variabel name</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.EnvironmentalMemory.Variable.Value">
      <summary>
Value of variable</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.EnvironmentalMemory.Variable.Type">
      <summary>
Type ass string identifier</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.EnvironmentalMemory.LocalMemory">
      <summary>
Memory for variables</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.EnvironmentalMemory.mGlobalMemory">
    </member>
    <member name="P:SDK.SmallProgLang.Compiler.EnvironmentalMemory.GlobalMemory">
      <summary>
Global memeory passed in from parent environment</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.EnvironmentalMemory.#ctor(SDK.SmallProgLang.Compiler.EnvironmentalMemory@)">
      <summary>
A global memeory is contained within environemt for referencing</summary>
      <param name="GlobalMemory">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.EnvironmentalMemory.#ctor">
      <summary>
Has no Global Memory</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.EnvironmentalMemory.Define(System.String@,System.String)">
      <summary>
Defines variable in environemnt if not previoulsy exisiting</summary>
      <param name="Name">
Variable name</param>
      <param name="nType">
stype such as string/ integer etc</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.EnvironmentalMemory.AssignValue(System.String@,System.Object@)">
      <summary>
Assigns a value to the variable</summary>
      <param name="Name">
Variable name(Previoulsy Exisiting)</param>
      <param name="Value">
Value to be stored</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.EnvironmentalMemory.GetVar(System.String@)">
      <summary>
Returns the value from the stored variable</summary>
      <param name="Name">
</param>
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.Lexer">
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.Cursor">
      <summary>
Cursor Position</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.EoFCursor">
      <summary>
Cursor Position</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.CurrentScript">
      <summary>
Program being Tokenized</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.iPastTokens">
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.iLastToken">
    </member>
    <member name="P:SDK.SmallProgLang.Compiler.Lexer.PastTokens">
    </member>
    <member name="P:SDK.SmallProgLang.Compiler.Lexer.LastToken">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.GetLastToken">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.GetSlice(System.String@,System.Int32@)">
      <summary>
Returns from index to end of file (Universal function)</summary>
      <param name="Str">
String</param>
      <param name="indx">
Index</param>
    </member>
    <member name="P:SDK.SmallProgLang.Compiler.Lexer.EndOfFile">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.GetNext">
      <summary>
Gets next token moves cursor forwards</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.ViewNext">
      <summary>
Checks token without moving the cursor</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.RegExSearch(System.String@,System.String)">
      <summary>
Main Searcher</summary>
      <param name="Text">
to be searched</param>
      <param name="Pattern">
RegEx Search String</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.StepBack(System.String@)">
      <summary>
Steps the tokenizer backwards</summary>
      <param name="TokenStr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.Eat(SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id@)">
      <param name="TokenType">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.IdentifiyToken(System.String@)">
      <summary>
Identifys token</summary>
      <param name="CurrentTok">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.GetIdentifiedToken(System.String@)">
      <summary>
Identifys token</summary>
      <param name="CurrentTok">
</param>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Lexer.CurrentGrammar">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.#ctor(System.String@)">
      <param name="Script">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.#ctor(System.String@,System.Collections.Generic.List{SDK.SmallProgLang.GrammarFactory.Grammar}@)">
      <summary>
Use for Sal and OtherLangs</summary>
      <param name="Script">
</param>
      <param name="Grammar">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Lexer.GetDebuggerDisplay">
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.Parser">
      <summary>
Programming Language Parser to AST</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Parser.ParserErrors">
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Parser.iScript">
      <summary>
Currently held script</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Parser.Lookahead">
      <summary>
To hold the look ahead value without consuming the value</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Parser.Tokenizer">
      <summary>
Tokenizer !</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.Parse(System.String@)">
      <summary>
Main Parser Function Parses whole Script into a AST tree ; Which can be used later for evaluation to be run on a vm or to generate code for a different language (interpretor) or (evaluator - Compiler(Executor)</summary>
      <returns>
AST PROGRAM</returns>
      <param name="nScript">
Script to be compiled</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.Parse(System.String@,System.Collections.Generic.List{SDK.SmallProgLang.GrammarFactory.Grammar}@)">
      <summary>
Main Parser Function Parses whole Script into a AST tree ; Which can be used later for evaluation to be run on a vm or to generate code for a different language (interpretor) or (evaluator - Compiler(Executor)</summary>
      <returns>
AST PROGRAM</returns>
      <param name="nScript">
Script to be compiled</param>
      <param name="Gramer">
Uses Custom Grammar to create tokens</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._ProgramNode">
      <summary>
Main Entry Point. Syntax: Program: -Literals</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._StatementList">
      <summary>
Syntax -Statement -Statementlist Statement -&gt; Statement Statement Statement</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._PrimaryExpression">
      <summary>
Syntax -Literal =&gt; (_PrimaryExpression)</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._literalNode">
      <summary>
-Literals Syntax: -Numeric Literal -String Literal -Comments -Nullable</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._NumericLiteralNode">
      <summary>
Syntax: Numeric Literal: -Number</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._NullableNode">
      <summary>
Syntax: Nullable Literal: -Null</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.__EmptyStatementNode">
      <summary>
Used for end of statement</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.__EndStatementNode">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.__UnknownStatementNode">
      <summary>
Collects bad token</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser.__UnknownStatementNode(SDK.SmallProgLang.GrammarFactory.Token@)">
      <summary>
Used when data has already been collected</summary>
      <param name="ErrorTok">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._WhitespaceNode">
      <summary>
Used to denote white space as it is often important later Some Parsers ignore this token ; It is thought also; to be prudent to collect all tokens to let the Evaluator deal with this later</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._CodeBeginNode">
      <summary>
Used to Eat Node</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._ConditionalBeginNode">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._CodeEndNode">
      <summary>
Used to Eat Node</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._ConditionalEndNode">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._BooleanNode">
      <summary>
Used to return boolean literals if badly detected it will return false</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._CommentsNode">
      <summary>
Syntax: Comments Literal: -Comments</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._StringLiteralNode">
      <summary>
Syntax: "hjk" String Literal: -String</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._IdentifierLiteralNode">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._Statement">
      <summary>
Syntax -ExpressionStatement -BlockStatement -IterationStatement</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._ExpressionStatement">
      <summary>
Gets Expression Statement Syntax -Expression ";"</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._Expression">
      <summary>
Syntax: -_PrimaryExpression(literal) -_MultiplicativeExpression -_AddativeExpression</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._BlockStatement">
      <summary>
Syntax: Could be Empty list So Prefix Optional { OptionalStatmentList }</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._VariableExpression">
      <summary>
Syntax: Variable: -Identifier as expression</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._ParenthesizedExpression">
      <summary>
Syntax: ( OptionalStatmentList; )</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._MultiplicativeExpression">
      <summary>
Syntax: -Multiplicative Expression Literal */ Literal</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._AddativeExpression">
      <summary>
Syntax: -Addative Expression Literal +- Literal</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._RelationalExpression">
      <summary>
Syntax: Literal Operator Literal _BinaryExpression RelationalOperator _BinaryExpression ..</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._BinaryExpression(SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id@,SDK.SmallProgLang.Ast_ExpressionFactory.AST_NODE,System.String)">
      <summary>
syntax: -Literal(Primary Expression) -Multiplicative Expression -Addative Expression -ConditionalExpression(OperationalExpression) -Assignment Expression</summary>
      <param name="NType">
</param>
      <param name="AstType">
</param>
      <param name="AstTypeStr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._BinaryExpression">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._GetAssignmentOperator">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Parser._IterationStatment">
      <summary>
Syntax -DoWhile -DoUntil _ForNext</summary>
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.S_Expression_Evaluator">
      <summary>
Evaluates Arrays of tokens, Taken from the populated AST NODES, The Expected format is Reverse poilsh Notation. Operator/ (Operands) The Product is returned ;</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.GlobalEnvironment">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.#ctor(SDK.SmallProgLang.Compiler.EnvironmentalMemory@)">
      <summary>
Create a new instance of the PROGRAMMING Interpretor</summary>
      <param name="iGlobal">
Used to provide preloaded environment</param>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.LineNumber">
      <summary>
Line number counter</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IncrLineNumber">
      <summary>
Increases the current line number to track the line number in the program</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.GetDebuggerDisplay">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.Eval(System.Object@,SDK.SmallProgLang.Compiler.EnvironmentalMemory)">
      <summary>
Used for imediate Evaluations</summary>
      <param name="Expr">
</param>
      <param name="Env">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.EvalBlock(System.Object@,SDK.SmallProgLang.Compiler.EnvironmentalMemory)">
      <summary>
Evaluates a block of code returning the Global Environment the block environment is disposed of</summary>
      <param name="Expr">
</param>
      <param name="Env">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator._CheckCondition(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IsNumberInt(System.Object@)">
      <summary>
Checks if expr is a number, Returning number</summary>
      <param name="Expr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IsString(System.Object@)">
      <summary>
Checks if Expr is string returning the string</summary>
      <param name="Expr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IsVariableName(System.Object@)">
      <summary>
If Epr token is variable ake then it can be handled correctlly</summary>
      <param name="Expr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IsBoolean(System.Object@)">
      <param name="Expr">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.S_Expression_Evaluator.IsArray(System.Object@)">
      <summary>
if token is an array then it contains an expression</summary>
      <param name="Expr">
</param>
    </member>
    <member name="T:SDK.SmallProgLang.Compiler.Sal_Transpiler">
      <summary>
Transpiles to SAL Code; Can be run on SAL Assembler</summary>
    </member>
    <member name="F:SDK.SmallProgLang.Compiler.Sal_Transpiler.LineNumber">
      <summary>
Line number counter</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Sal_Transpiler.IncrLineNumber">
      <summary>
Increases the current line number to track the line number in the program</summary>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Sal_Transpiler.GetDebuggerDisplay">
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Sal_Transpiler.Transpile(SDK.SmallProgLang.Ast_ExpressionFactory.AstExpression@)">
      <summary>
As Each Expression is consumed an program will be returned Each Expression Should be an array Provided by the AST toArray Function Which only Creates the Desired nodes in the order Expected by the Transpiler(RPL)</summary>
      <param name="Ast">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Sal_Transpiler._Binary_op(System.Int32@,System.Int32@,System.String@)">
      <summary>
Generates SalCode For Binary ops -Simple Assign -Conditional -Addative -Multiplicative</summary>
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.Compiler.Sal_Transpiler._print(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="T:SDK.SmallProgLang.EXT">
      <summary>
Minor Extension Methods; Required for json formatting</summary>
    </member>
    <member name="M:SDK.SmallProgLang.EXT.FormatJsonOutput(System.String)">
      <param name="jsonString">
</param>
    </member>
    <member name="M:SDK.SmallProgLang.EXT.ToJson(System.Object@)">
      <param name="item">
</param>
    </member>
    <member name="N:SDK.SmallProgLang.GrammarFactory">
    </member>
    <member name="T:SDK.SmallProgLang.GrammarFactory.Grammar">
      <summary>
Simple Gramar object (Expected token Shape or from)</summary>
    </member>
    <member name="T:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id">
      <summary>
GRAMMAR OBJECT ID</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._INTEGER">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._STRING">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._VARIABLE">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._WHITESPACE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._COMMENTS">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._PRINT">
      <summary>
Print Literal/Value/String</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._DIM">
      <summary>
Declare Var</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._FOR">
      <summary>
Begin Iteration of list For (Iterator = (Increment to Completion)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._EACH">
      <summary>
Additional = Step +1</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._IN">
      <summary>
From item in list</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._TO">
      <summary>
End of iteration marker</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._NEXT">
      <summary>
Increment Iterator</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._IF">
      <summary>
If Condition = Outcome Then (code) Else (code)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._THEN">
      <summary>
Then (block)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._ELSE">
      <summary>
Else (Block)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._UNTIL">
      <summary>
Until Condition = true</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._WHILE">
      <summary>
While Condition = true</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._DO">
      <summary>
Signify begining of Do...While/Until</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._RETURN">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._FUNCTION">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._SUB">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._CLASS">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._NEW">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._AS">
      <summary>
Used in Declaration Assignment Left (var) assign as (LiteralType)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LOOP">
      <summary>
End of While loop (marker)(check expression Condition)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._SIMPLE_ASSIGN">
      <summary>
xLeft = output of right (9+4) (+= 9) (-=2) (3) (true)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._COMPLEX_ASSIGN">
      <summary>
xLeft assigns output of right -=(9+4) (+= 9) (-=2) (3) (true) Complex assign ... x=x+(ouput)x=x-(ouput) etc</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._TRUE">
      <summary>
Boolean Literal Env Variable</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._FALSE">
      <summary>
Boolean Literal - Env Variable</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._NULL">
      <summary>
Boolean literal -Env Variable</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LIST_BEGIN">
      <summary>
Used for Args List (Lists) = Arrays Args are lists of Vars (function Environment Vars)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LIST_END">
      <summary>
End of List</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._CODE_BEGIN">
      <summary>
Used for Blocks of code</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._CODE_END">
      <summary>
End of Code block</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._CONDITIONAL_BEGIN">
      <summary>
Used for operation blocks as well as ordering prioritizing evals Begin</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._CONDITIONAL_END">
      <summary>
End of Condition</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LOGICAL_AND">
      <summary>
- AND</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LOGICAL_OR">
      <summary>
| OR</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LOGICAL_NOT">
      <summary>
! NOT</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._RELATIONAL_OPERATOR">
      <summary>
Greater than / Less Than</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._ADDITIVE_OPERATOR">
      <summary>
+-</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._MULTIPLICATIVE_OPERATOR">
      <summary>
*/</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._STATEMENT_END">
      <summary>
;</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._EOF">
      <summary>
end of file</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._BAD_TOKEN">
      <summary>
Bad / Unrecognized token</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._LIST_SEPERATOR">
      <summary>
Seperates items in list</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._NOT_EQUALS">
      <summary>
!=</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id._VARIABLE_DECLARE">
      <summary>
DECLARE VAR</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_NULL">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_REMOVE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_RESUME">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PUSH">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PULL">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PEEK">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_WAIT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PAUSE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_HALT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_DUP">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JMP">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JIF_T">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JIF_F">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JIF_EQ">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JIF_GT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_JIF_LT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_LOAD">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_STORE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_CALL">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_RET">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PRINT_M">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_PRINT_C">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_ADD">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_SUB">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_MUL">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_DIV">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_AND">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_OR">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_NOT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_IS_EQ">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_IS_GT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_IS_GTE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_IS_LT">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_IS_LTE">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_TO_POS">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_TO_NEG">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_INCR">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Type_Id.SAL_DECR">
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.ID">
      <summary>
Identifier</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Grammar.Exp">
      <summary>
RegEx Expression to search</summary>
    </member>
    <member name="M:SDK.SmallProgLang.GrammarFactory.Grammar.GetPLGrammar">
      <summary>
Set OF KeyWords for Language with RegEx Search Expressions Based on basic programming languge keywords and symbols /Literals This is a preloaded Grammar (list of Grammar objects)</summary>
    </member>
    <member name="M:SDK.SmallProgLang.GrammarFactory.Grammar.GetSALGrammar">
    </member>
    <member name="T:SDK.SmallProgLang.GrammarFactory.Token">
      <summary>
Token to be returned</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Token.ID">
      <summary>
Simple identifier</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Token.Value">
      <summary>
Held Data</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Token._start">
      <summary>
Start of token(Start position)</summary>
    </member>
    <member name="F:SDK.SmallProgLang.GrammarFactory.Token._End">
      <summary>
End of token (end Position)</summary>
    </member>
    <member name="M:SDK.SmallProgLang.GrammarFactory.Token.ToJson">
    </member>
    <member name="N:SDK">
    </member>
  </members>
</doc>
